{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Partition Tables</p> <p>I could make you read all week on the topic of partition tables and their underlying metadata. You would sleep well but learn nothing! By getting you to extract metadata structures, map and understand them, we can ensure a basic understanding. Before you start, you need to make sure you have understood my notes on volume organisation. If you approach this methodically, it will all work fine.</p> <p>You will be required to keep a list of commands with notes as to why you are using them as well as results of any testing you have done. You may be asked to present these notes as evidence of work completed or as part of a lab book. Check with your lecturer.</p>"},{"location":"1.%20MBR/1/","title":"Getting started","text":"<p>This exercise is intended to;</p> <ol> <li>Familiarise the student with basic tools for reconnaissance at a byte level in Windows</li> <li>Demonstrate the meta-data associated with a sample MBR volume.</li> </ol>"},{"location":"1.%20MBR/1/#preparation","title":"Preparation","text":"<ol> <li>Do all this work in a VM</li> <li>Obtain a disk sector editor such as WinHex.</li> <li>Create a virtual disk in Windows as previously demonstrated in practical sessions. You may use diskpart or the graphical disk tools. </li> <li>Document this disk's main parameters.</li> <li>Initialize the disk as an MBR disk.</li> <li>Create as many primary partitions as you can and create at least two extended partitions. </li> </ol> <p>I expect every student's partitions will be different!</p>"},{"location":"1.%20MBR/1/#demonstration","title":"Demonstration","text":"<p>You may carry these exercises out both in Windows or in Linux, But to use a VM in every case.</p>"},{"location":"1.%20MBR/1/#windows","title":"Windows","text":"<p>If you are using Windows, you can use the free tool WinHex or any other sector editor of your choice.</p> Fig 1. Winhex."},{"location":"1.%20MBR/1/#linux","title":"Linux","text":"<p>In this example, I am doing a walkthrough using Linux and the commands dd and hexdump. All the same principles apply whether you are using Linux or Windows. I created a virtual disk (sdb) to work with and mounted it to the VM.</p> Fig 2. dd and hexdump."},{"location":"1.%20MBR/2/","title":"Interpreting the Structure","text":"<p>In MBR</p> <ul> <li>From byte 0-445 are the boot loader and will probably be empty for a non-bootable partition.</li> <li>Each partition entry is 16 bytes long.</li> <li>Partition entry 1 will begin at offset 446 or 0x1BE</li> <li>Partition entry 2 will begin at offset 462 or 0x1CE  </li> <li>Partition entry 3 will begin at offset 478 or 0x1DE</li> <li>Partition entry 2 will begin at offset 494 or 0x1FE</li> <li>The end of the first sector is flagged by 0xAA55 at offset 510 and 511</li> <li>I had four partitions. By examining the MBR in detail, I can map these partitions, using an Excel sheet.</li> </ul> Fig 3. MBR. <p>Partition 1 is a primary partition.</p> Fig 4. Partition 1 raw bytes. <p>Partition 2 is a primary partition.</p> Fig 5. Partition 2 raw bytes. <p>Partition 3 is a primary partition.</p> Fig 6. Partition 3 raw bytes. <p>Partition 4 is a primary partition, type 05, extended.</p> Fig 7. Partition 4 raw bytes. <p>Each byte is (obviously) 8 bits, but we store 16 or 32 bit words, each word is more than one byte. In what order do we store these bytes?</p> <ul> <li>We can store most significant byte (MSB) first and least significant byte (LSB) second, this is big endian. The number 0x12345678 is stored as 12 34 56 78 </li> <li>We can store LSB first and MSB second, this is little endian. The number 0x12345678 would be stored as 78 56 34 12 </li> </ul> <p>The signature should be 0xAA55, so the dump is little-endian (red).</p> Fig 8. Signature."},{"location":"1.%20MBR/3/","title":"Interpreting the Metadata","text":"<p>I am going to work through my data, and you should be able to follow my methodology. Do this in excel using your own data.</p> <p>For each partition;</p> <ul> <li>Byte 0 is the Flag or Boot Indicator, this tells us is the partition is bootable. 80 = Bootable, 0 = Not!</li> <li>Byte 1-3 are the starting CHS value (ignore)</li> <li>Byte 4 is the partition type</li> <li>Byte 5-7 are the end CHS (ignore)</li> <li>Byte 8-11 are the partition start with the starting sector in LBA </li> <li>Byte 12-15 are the partition size</li> </ul>"},{"location":"1.%20MBR/3/#partition-1","title":"Partition 1","text":"<ul> <li>The partition is not bootable</li> <li>Partition type is 0x83, Linux</li> <li>LBA starts at 0x0000003f (4 bytes, little endian).</li> <li>LBA size is 0x0000bc04 (4 bytes, little endian), 48,132 * 512= 24,643,584 bytes</li> </ul> Fig 9. Partition 1 decoding."},{"location":"1.%20MBR/3/#partition-2","title":"Partition 2","text":"<ul> <li>The partition is not bootable</li> <li>Partition type is 0x83, Linux</li> <li>LBA starts at 0x0000bc43</li> <li>LBA size is LBA Size 0x0000bc43, 48,195 * 512= 24,675,840 bytes</li> </ul> Fig 10. Partition 2 decoding."},{"location":"1.%20MBR/3/#partition-3","title":"Partition 3","text":"<ul> <li>The partition is not bootable</li> <li>Partition type is 0x04, FAT16 &lt; 32MB</li> <li>LBA starts at 0x0017886</li> <li>LBA size is LBA Size 0x00007d82, 32,133 * 512= 16,452,096 bytes</li> </ul> Fig 11. Partition 3 decoding."},{"location":"1.%20MBR/3/#partition-4","title":"Partition 4","text":"<ul> <li>The partition is not bootable</li> <li>Partition type is 0x05, Extended</li> <li>LBA starts at 0x001f608</li> <li>LBA size is LBA Size 0x0000fb04, 64,260 * 512= 32,901,120 bytes</li> </ul> Fig 12. Partition 4 decoding."},{"location":"1.%20MBR/4/","title":"Understanding the Extended Partition","text":"<p>The extended partition started at 0x0001f608, so starting at sector 128,520 and as it is an extended partition, we should find another partition table here!</p> <p>The LBA Size 0x0000fb04 or 64,260 so the partition should end at sector 128,520 + 64,260 = 192,780</p> <p>I used hexdump to look at this sector to find the partition table in the extended partition, you may use any tool (e.g. WinHex if you are using Windows).</p> Fig 13. First sector, extended partition. <p>Decoding this block, I get another partition table with two entries.</p> Fig 14. Extended partition, new partition table."},{"location":"1.%20MBR/4/#extended-partition-1","title":"Extended Partition 1","text":"<ul> <li>The partition is not bootable</li> <li>Partition type is 0x83, Linux</li> <li>LBA starts at 0x0000003f</li> <li>LBA size is LBA Size 0x00007d43, 32,067 * 512= 16,418,304 bytes</li> </ul> Fig 15. Extended partition 1. <p>Now I know where the second partition in the extended partition is!</p> <ul> <li>The LBA start of primary partition was 0x0001f608, so it starts at sector 128,520.</li> <li>The LBA start of secondary partition relative to the first is 0x00007d82 or 32,130 relative to the start.</li> <li>128,520 + 32,130 = 160,650, we should find another partition table here!</li> </ul> <p>I used hexdump to look at this sector to find the partition table in the extended partition, you may use any tool (e.g. WinHex if you are using Windows).</p> Fig 16. Extended partition 1, partition table."},{"location":"1.%20MBR/4/#extended-partition-2","title":"Extended Partition 2","text":"<p>Decoding this block, I get another partition table with one entry. This is the last partition!</p> Fig 17. Extended partition 2, partition table. <ul> <li>The partition is not bootable</li> <li>Partition type is 0x83, Linux</li> <li>LBA starts at 0x0000003f</li> <li>LBA size is LBA Size 0x00007d43, 32,067 * 512= 16,418,304 bytes</li> </ul> Fig 18. Extended partition 2, partition table."},{"location":"1.%20MBR/5/","title":"Summary","text":"<p>I did a diagram to summarize the layout of this extended partition.</p> Fig 19. MBR Summary."},{"location":"2.%20GPT/6/","title":"Getting started","text":"<p>GPT is an order of magnitude more complex, and I am not going to get you to do the same forensic drill down. However, I will bring you to the starting point, you could continue should you so desire.</p>"},{"location":"2.%20GPT/6/#preparation","title":"Preparation","text":""},{"location":"2.%20GPT/6/#windows-users","title":"Windows users","text":"<ul> <li>Create a virtual disk in Windows as previously demonstrated in practical sessions. You may use diskpart or the graphical disk tools.</li> <li>Initialize the disk as an GPT disk.</li> <li>Create four primary partitions. </li> </ul>"},{"location":"2.%20GPT/6/#linux-users","title":"Linux Users","text":"<ul> <li>Create an additional virtual hard drive on a Linux VM.</li> <li>This should show up as /dev/sdb</li> </ul> <p>Using gdisk  - Initialize the disk as an GPT disk. - Create four primary partitions. \u2003</p>"},{"location":"2.%20GPT/6/#build","title":"Build","text":"<p>In this example, I am doing a walkthrough using Windows and the free tool WinHex. All the same principles apply whether you are using Linux or Windows.</p> <ul> <li>Start off by documenting all disks which show in your system. If you pick the wrong disk later, you may render your system unusable!</li> <li>Created a VHD in Disk Manager, 1,000MB in size.</li> <li>For me, the disk was attached as soon as it was created. If not, attach the disk.</li> <li>Make sure you can identify which disk the VHD is before you continue; if in doubt, STOP!!</li> </ul> Fig 20. The VHD. <p>Open the new disk in WinHex (or any similar tool) and verify that the disk is blank; that all sectors are zero.</p> Fig 21. Verify a clear disk. <p>Right-click on the new disk and initialize.</p> Fig 22. Initialize. <p>Document the disk number (10 in my case) and select GPT.</p> Fig 23. Disk summary."},{"location":"2.%20GPT/7/","title":"Interpreting the Structure","text":"<p>I am going to go through this methodically to identify the main metadata.</p>"},{"location":"2.%20GPT/7/#lba0-the-protective-mbr","title":"LBA0 - The Protective MBR","text":"<p>The first 512 bytes hold the Protective MBR.</p> Fig 24. The Protective MBR. <p>If we examine the first entry in the partition table, we see the partition type EE, signifying that it is a protective MBR.</p> Fig 25. The partition table."},{"location":"2.%20GPT/7/#lba1-the-efi-header","title":"LBA1 - The EFI Header","text":"<p>The next 512 bytes are the EFI Header.</p> Fig 26. The EFI Header. <p>Mapping that data to fields (using the key in the diagram above) gives me the following table.</p> Fig 27. EFI Data. <p>The LBA for the start of the partition table is 02 and we can confirm that there is a partition table there.</p> Fig 28. LBA 02. <p>Mapping that data to fields (using the key in the diagram above) gives me the following table.</p> Fig 28. LBA 02. <p>This was just an easy start and we will not go any further into this for now.</p>"}]}